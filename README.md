# bitoip

## What

bit-over-ip: Low level protocol for sending timed on-off state over TCP/IP or UDP/IP

## Why

I'm looking for a way to transmit hand-keyed and keyer-keyed morse over the
internet.  Ideally, this is via a toggled line on a serial port or software
generated from morse keying or morse decoding software.

There is one bit that is toggled on and off, and the timing is important, so something that
is stream-oriented in that it can reconstruct time is important. The bandwidth needed
is some small number of bits per second.


## Concepts

A **stream** is a series of timed on and off events.  Streams have:
 - A marking zero time, that represents the beginning of the bitstream.  This might be tied to some real time, but
 is really for the participants in the stream.
 - a unique id generated by the creator that represents this stream
 - on/off events for one or more bits in the stream

We are aiming for streams that are:
- very low in bandwidth used
- somewhat tolerant of message loss with these caveats:
  - we always want to fail with the bit off if we can (which implies what can be put in a message)
  - we want control messages to be confirmed and repeated if needed
- easily combinable
- can be recorded and replayed later, so can be recorded without loss.

A **carrier** is a set of bit on/off events for a single bit.  A carrier has:
 - an id (which is used to differentiate different bits in a stream)
 - a series of on and off events and control messages
 - some sort of source id (like a string callsign)

A **channel** is a named grouping of carriers.  A server may support one or more channels.  A channel has:
 - a control interface to allow:
    - enumeration of carriers
    - subscription and unsubscription
 - a name.  Should be unique in a server
 - combining with a server IP address and port, should be possible to make a channel URI

A **server** can receive and publish one or more channels.

## How this works

A client would connect to a server and probably get an enumeration of channels.  The client can then
subscribe to a channel to receive carrier packets related to that channel.  The subscription results in time
sync being established for that channel, and then the client will receive packets relating to that channel.  The client
can also transmit packets relating to that channel based on the time sync.



## Protocol

The protocol is composed of packets containing timed on and off information for a bit, with the
necessary time offsets from the start of the stream.

There is a facility to communicate basic key/value ascii pairs.

Generally, top bit set means that is a control value.

## Listen
LI (Listen) == 0x80

0x80, port_number, 0x00 (off) | 0x01 (on)

### Key-value pairs

KV (Key Value) == 0x81:

0x81, length (bytes), bytes, length, value_ascii...

### Bit/stream events

BE (Bit Event: timed) == 0x82:

0x82, flags(1 byte), 4-byte-timestamp (ms) from send start, event_type

event_type is:
0x00: bit off
0x01: bit on

flags: bitwise flags
Not currently used

timestamp=0 for converstation start start

## Stream Semantics
0x80 listen (port) <-- listening at source IP:port
0x82 start stream -- sets time zero for (fromip, fromport)
0x83 end stream  -- stop keeping time

## Example converstation 

1. Establish a listener socket and send LI (eg. port 0x4001)

0x80, 0x40, 0x01, 0x01

2. Set callsign KV pair (optional)

0x81, 0x02, D, E, 0x06, G, 0, W, C, Z

3. Send something

This sends a dit at about 25wpm
0x82, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
0x82 0x00, 0x00, 0x00, 0x00, 0x30, 0x00








## Questions

How about direct udp-udp connections. Why not?


